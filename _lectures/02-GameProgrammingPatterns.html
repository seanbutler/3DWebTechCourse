---
layout: slides
title:  "Javascript: The Good The Bad and the Ugly"
date:   2017-09-13 23:46:24 +0100
---

<section data-background-color="#ff7f00">
    <h1>Game Programming Patterns in JS</h1>
    <p>part of 3d tech for the web course</p>
    <p>stole a lot of this content from <a href = "http://gameprogrammingpatterns.com/">game programming patterns</a></p>
</section>

<section>
    <h2>Aims and Objectives</h2>
    <p>Recognise Patterns</p>
    <p>Code Them Up</p>
    <p>Understand Their Motivations</p>
</section>

<section>
    <h2>Audience</h2>
    <p>Novice JS programmers who want to make 3d web games or similar systems</p>
</section>

<section>
    <h2>Definition</h2>
    <p>What is a Pattern?</p>
    <p>What is a Software Design Pattern?</p>
    <p>What is a Game Programming Pattern?</p>
</section>

<section>
    <h2>Definition</h2>
    <p></p>
</section>

<section>
    <h2>Some Patterns</h2>
    <ul>
        <li>Game Loop</li>
        <li>Update Method</li>
        <li>Update Method</li>
        <li>Entity</li>
        <li>Singleton</li>
        <li>Object Pool</li>
        <li>Prototype</li>
        <li>Component</li>
        <li>Service</li>
    </ul>
</section>

<section>
    <h2>Types of Patterns</h2>
    <ul>
        <li>Structural</li>
        <li>Sequence</li>
        <li>Decoupling</li>
        <li>Optimisation</li>
    </ul>
</section>

<section>
    <h2>Game Loop</h2>

    <section>
        <img src = "../../assets/game-loop-simple.png">
<code>
<pre>
var animate = function () {
    requestAnimationFrame( animate );

    processInput();
    updateEntities();
    renderScene(scene, camera);
};
</pre>
</code>
    </section>

    <section>
        <table>
            <tr class = "fragment"><td>What</td><td>Runs continuously, processes user input without blocking, updates game state, and renders the game. Tracks the passage of time to control the rate of gameplay</td></tr>
            <tr class = "fragment"><td>Why</td><td>Decouple game time from user input and processor speed. Real Time systems run continuously and very quickly to create an illusion of continuous reality</td></tr>
            <tr class = "fragment"><td>When</td><td>Every realtime game requires its use in some form</td></tr>
        </table>
    </section>

</section>


<section>
    <p>Game Object</p>

    <section>
    <code>
        <pre>
            class GameObject {
                constructor(x, y, z){
                    this.x = x;
                    this.y = y;
                    this.z = z;
                };
                Render(){};
                Logic(){};

            }

            class Player extends GameObject { constructor(){}; }
            class Enemy extends GameObject { constructor(){}; }
            class Nazi extends Enemy { constructor(){}; }
        </pre>
    </code>
    </section>

    <section>
        <table>
          <tr class = "fragment"><td>Description</td><td>Many (most) of the objects in your system will have something in common which is necessary for them to participate in the simulation.</td></tr>
          <tr class = "fragment"><td>Motivation</td><td>Because they all are part of the same simulation you dont want to re-write the code each time.</td></tr>
        </table>
    </section>
</section>

<section>
    <p>Update Method</p>

    <section>
    <code>
        <pre>
class Player
{
    constructor(_z, _y) {this.x = _x; this.y=_y}
    Update() {}
}

while (gameOn==true)
{
    handleInput();

    for (int i = 0; i < numEntities_; i++)
    {
      entities_[i]->update();
    }

    renderScene(camera, scene);
}
        </pre>
    </code>
    </section>

        <section>
            <table>
              <tr class = "fragment"><td>Description</td><td>The game world maintains a collection of objects. Each object implements an update method that simulates one frame of the object’s behavior. Each frame, the game updates every object in the collection.</td></tr>
              <tr class = "fragment"><td>Motivation</td><td>Your game has a number of objects or systems that need to run simultaneously. Each object’s behavior is mostly independent of the others. The objects need to be simulated over time.</td></tr>
            </table>
        </section>
    </section>





<section>
    <p>Object Pool</p>
</section>

<section>
    <p>Prototype</p>
</section>



<section>
    <p>Component</p>
</section>

<section>
    <p>Service</p>
</section>



<section>
    <h2>Singeton</h2>

    <section>
<code>
<pre>
var Singleton = (function () {
    var instance;

    function createInstance() {
        var object = new Object("I am the instance");
        return object;
    }

    return {
        getInstance: function () {
            if (!instance) {
                instance = createInstance();
            }
            return instance;
        }
    };
})();
</pre>
</code>
    </section>

    <section>
        <table>
          <tr class = "fragment"><td>Description</td><td>Ensure a class has only one instance, and provide a global point of access to it</td></tr>
          <tr class = "fragment"><td>Motivation</td><td>Useful when exactly one object is needed to coordinate actions across the entire system</td></tr>
          <tr class = "fragment"><td>Example</td><td>Example</td></tr>
        </table>
    </section>
</section>



<section>
    <h2>More Patterns</h2>
    <ul>
        <li>Flyweight</li>
        <li>Spatial Partition</li>
        <li>Scene Graph</li>
    </ul>
</section>


<section>
    <h2>Further Reading</h2>
    <small>
        <p>http://gameprogrammingpatterns.com/</p>
        <p>https://en.wikipedia.org/wiki/Software_design_pattern</p>
        <p>https://en.wikipedia.org/wiki/A_Pattern_Language</p>
    </small>
</section>
